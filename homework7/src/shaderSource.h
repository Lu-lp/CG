#ifndef SHADER_SOURCE
#define SHADER_SOURCE
// 用于渲染光源的shader代码-------------------------------------------------
const char* depthBufferVerticeShaderSource = "#version 330 core\n"
"layout(location = 0) in vec3 aPos;\n"
"uniform mat4 model;\n"
"uniform mat4 lightSpaceMatrix;\n"
"void main()\n"
"{\n"
"	gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);\n"
"}\n\0";

const char* depthBufferFragmentShaderSource = "#version 330 core\n"
"void main()\n"
"{\n"
"	// gl_FragDepth = gl_FragCoord.z;\n"
"}\n\0";

// 用于渲染物体的Phong shading 代码-----------------------------------------
const char* phongVerticeSharderSource = "#version 330 core\n"
"layout(location = 0) in vec3 aPos;\n"
"layout(location = 1) in vec3 aNormal;\n"
"layout(location = 2) in vec2 aTexCoords;\n"
"out vec2 TexCoords;\n"
"out VS_OUT{\n"
"	vec3 FragPos;\n"
"vec3 Normal;\n"
"vec2 TexCoords;\n"
"vec4 FragPosLightSpace;\n"
"} vs_out;\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"uniform mat4 model;\n"
"uniform mat4 lightSpaceMatrix;\n"
"void main()\n"
"{\n"
"	vs_out.FragPos = vec3(model * vec4(aPos, 1.0));\n"
"	vs_out.Normal = transpose(inverse(mat3(model))) * aNormal;\n"
"	vs_out.TexCoords = aTexCoords;\n"
"	vs_out.FragPosLightSpace = lightSpaceMatrix * vec4(vs_out.FragPos, 1.0);\n"
"	gl_Position = projection * view * model * vec4(aPos, 1.0);\n"
"}\n\0";
const char* phongFragmentSharderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in VS_OUT{\n"
"	vec3 FragPos;\n"
"vec3 Normal;\n"
"vec2 TexCoords;\n"
"vec4 FragPosLightSpace;\n"
"} fs_in;\n"
"uniform sampler2D diffuseTexture;\n"
"uniform sampler2D shadowMap;\n"
"uniform vec3 lightPos;\n"
"uniform vec3 viewPos;\n"
"float ShadowCalculation(vec4 fragPosLightSpace)\n"
"{\n"
"	// 执行透视除法\n"
"	vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n"
"	// 将坐标的范围规定在[0,1]\n"
"	projCoords = projCoords * 0.5 + 0.5;\n"
"	// 获得最近的深度值\n"
"	float closestDepth = texture(shadowMap, projCoords.xy).r;\n"
"	// 得到当前片段在以光为视角的深度\n"
"	float currentDepth = projCoords.z;\n"
"	// check whether current frag pos is in shadow\n"
"	float bias = 0.005;\n"
"	float shadow = 0.0;\n"
"	vec2 texelSize = 1.0 / textureSize(shadowMap, 0);\n"
"	for (int x = -1; x <= 1; ++x)\n"
"	{\n"
"		for (int y = -1; y <= 1; ++y)\n"
"		{\n"
"			float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n"
"			shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;\n"
"		}\n"
"	}\n"
"	shadow /= 9.0;\n"
"	if (projCoords.z > 1.0) \n"
"		shadow = 0.0;\n"
"	return shadow;\n"
"}\n"
"void main()\n"
"{\n"
"	vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb;\n"
"	vec3 normal = normalize(fs_in.Normal);\n"
"	vec3 lightColor = vec3(0.3);\n"
"	// ambient\n"
"	vec3 ambient = 0.3 * color;\n"
"	// diffuse\n"
"	vec3 lightDir = normalize(lightPos - fs_in.FragPos);\n"
"	float diff = max(dot(lightDir, normal), 0.0);\n"
"	vec3 diffuse = diff * lightColor;\n"
"	// specular\n"
"	vec3 viewDir = normalize(viewPos - fs_in.FragPos);\n"
"	vec3 reflectDir = reflect(-lightDir, normal);\n"
"	float spec = 0.0;\n"
"	vec3 halfwayDir = normalize(lightDir + viewDir);\n"
"	spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);\n"
"	vec3 specular = spec * lightColor;\n"
"	// calculate shadow\n"
"	float shadow = ShadowCalculation(fs_in.FragPosLightSpace);\n"
"	vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;\n"
"\n"
"	FragColor = vec4(lighting, 1.0);\n"
"}\n\0";

#endif